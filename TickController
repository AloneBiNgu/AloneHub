-- Tick.lua
--!strict

-- THAY ĐỔI 1: Thêm hằng số cho khoảng thời gian tick
local TICK_INTERVAL = 1 -- Giây. Runner sẽ "thức dậy" mỗi giây một lần để kiểm tra các job đến hạn.

local Tick = {}
Tick.__index = Tick

type Job = {
	name: string,
	interval: number,          -- giây
	jitterPct: number,         -- vd: 0.2 => ±20%
	running: boolean,
	enabled: boolean,
	fn: (() -> (number|nil)),
	nextAt: number,            -- thời điểm (os.clock) chạy lần tới
	version: number,           -- tăng mỗi lần add/cancel/enable/disable
}

local function withJitter(base: number, pct: number): number
	if pct <= 0 then return base end
	local d = base * pct
	return math.max(0.05, base + (math.random() * 2 * d - d))
end

local function now(): number
	return os.clock()
end

-- Hàng đợi (ưu tiên theo nextAt, nhỏ trước)
local function queueInsert(q: { {name: string, at: number} }, item)
	local i = #q + 1
	q[i] = item
	while i > 1 and q[i-1].at > q[i].at do
		q[i-1], q[i] = q[i], q[i-1]
		i -= 1
	end
end

local function queuePeek(q) return q[1] end
local function queuePop(q)
	if #q == 0 then return nil end
	local it = q[1]
	table.remove(q, 1)
	return it
end

function Tick.new()
	local self = setmetatable({}, Tick)
	self._jobs = {} :: {[string]: Job}
	self._queue = {} :: { {name: string, at: number} }
	self._runnerAlive = false
	return self
end

function Tick:_planNext(j: Job, delaySec: number?)
	local d = delaySec
	if d == nil then
		d = withJitter(j.interval, j.jitterPct)
	end
	local t = math.max(0.05, d :: number)
	j.nextAt = now() + t
	queueInsert(self._queue, { name = j.name, at = j.nextAt })
	if not self._runnerAlive then
		self:_startRunner()
	end
end

-- THAY ĐỔI 2: Chỉnh sửa hoàn toàn logic của runner
function Tick:_startRunner()
	if self._runnerAlive then return end
	self._runnerAlive = true

	task.spawn(function()
		while #self._jobs > 0 do -- Chạy khi nào còn jobs, thay vì queue
			local tnow = now()
			
			-- Chạy tất cả các job đã đến hạn trong "tick" này
			while #self._queue > 0 and (queuePeek(self._queue).at <= tnow) do
				-- Lấy và xác nhận
				local item = queuePop(self._queue)
				if not item then break end
				
				local j = self._jobs[item.name]
				if not j or not j.enabled then
					continue -- job bị huỷ/disable, bỏ qua
				end

				-- Nếu entry không còn khớp nextAt hiện tại, tức đã có lịch mới → bỏ qua
				if math.abs(item.at - j.nextAt) > 1e-6 then
					continue
				end
				
				-- Chạy job (chỉ chạy nếu nó không đang chạy)
				if not j.running then
					j.running = true
					local ok, ret = pcall(j.fn)
					j.running = false

					local delay: number? = nil
					if ok and type(ret) == "number" and ret >= 0 then
						delay = ret
					end
					
					-- Lên lịch lại cho lần chạy kế tiếp
					self:_planNext(j, delay)
				else
					-- phòng thủ: nếu vì lý do gì đó đang running, dời 1 chút
					self:_planNext(j, 0.25)
				end
			end
			
			-- Chờ cho đến tick tiếp theo
			task.wait(TICK_INTERVAL)
		end
		
		-- Vòng lặp kết thúc, tức là không còn job nào cả
		self._runnerAlive = false
	end)
end


function Tick:add(name: string, interval: number, fn: (() -> (number|nil)), jitterPct: number?)
	local j = self._jobs[name]
	if j == nil then
		j = {
			name = name,
			interval = interval,
			jitterPct = jitterPct or 0,
			running = false,
			enabled = true,
			fn = fn,
			nextAt = 0,
			version = 0,
		}
		self._jobs[name] = j
	else
		j.interval = interval
		j.jitterPct = jitterPct or j.jitterPct
		j.fn = fn
		j.enabled = true
	end
	j.version += 1
	self:_planNext(j, withJitter(interval, j.jitterPct))
end

function Tick:enable(name: string, on: boolean)
	local j = self._jobs[name]
	if not j then return end
	if j.enabled == on then return end
	j.enabled = on
	j.version += 1
	if on then
		self:_planNext(j, withJitter(j.interval, j.jitterPct))
	end
end

function Tick:cancel(name: string)
	local j = self._jobs[name]
	if not j then return end
	j.enabled = false
	j.version += 1
	self._jobs[name] = nil
end

return Tick
