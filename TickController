--!strict
local Tick = {}
Tick.__index = Tick

type Job = {
	name: string,
	interval: number,
	jitterPct: number,
	running: boolean,
	enabled: boolean,
	fn: (() -> (number|nil)),
	nextAt: number,
	version: number,
}

-- Tối ưu: Giảm SLACK xuống 1 frame để giảm overhead
local SLACK = 1/10           -- ~16ms, chính xác hơn
local MAX_BATCH = 5         -- Tăng batch size
local MIN_DELAY = 1/10       -- Align với frame rate

-- Cache math functions
local math_max = math.max
local math_random = math.random
local math_abs = math.abs
local table_remove = table.remove

-- Tối ưu: Pre-calculate để tránh tính lại
local function withJitter(base: number, pct: number): number
	if pct <= 0 then return base end
	local d = base * pct
	local jitter = math_random() * 2 * d - d
	return math_max(MIN_DELAY, base + jitter)
end

local function now(): number
	return os.clock()
end

-- Tối ưu: Binary heap thay vì insertion sort (O(log n) vs O(n))
local function heapInsert(q: {{name: string, at: number}}, item)
	local n = #q + 1
	q[n] = item
	
	-- Bubble up
	while n > 1 do
		local parent = math.floor(n / 2)
		if q[parent].at <= q[n].at then break end
		q[parent], q[n] = q[n], q[parent]
		n = parent
	end
end

local function heapPeek(q)
	return q[1]
end

local function heapPop(q)
	local len = #q
	if len == 0 then return nil end
	
	local root = q[1]
	q[1] = q[len]
	q[len] = nil
	len -= 1
	
	if len == 0 then return root end
	
	-- Bubble down
	local i = 1
	while true do
		local left = i * 2
		local right = left + 1
		local smallest = i
		
		if left <= len and q[left].at < q[smallest].at then
			smallest = left
		end
		if right <= len and q[right].at < q[smallest].at then
			smallest = right
		end
		
		if smallest == i then break end
		
		q[i], q[smallest] = q[smallest], q[i]
		i = smallest
	end
	
	return root
end

function Tick.new()
	local self = setmetatable({}, Tick)
	self._jobs = {} :: {[string]: Job}
	self._queue = {} :: {{name: string, at: number}}
	self._runnerAlive = false
	return self
end

function Tick:_planNext(j: Job, delaySec: number?)
	local d = delaySec or withJitter(j.interval, j.jitterPct)
	local t = math_max(MIN_DELAY, d)
	j.nextAt = now() + t
	heapInsert(self._queue, {name = j.name, at = j.nextAt})
	
	if not self._runnerAlive then
		self:_startRunner()
	end
end

-- Tối ưu: Giảm số lần gọi now(), tối ưu batch processing
function Tick:_startRunner()
	if self._runnerAlive then return end
	self._runnerAlive = true

	task.spawn(function()
		while #self._queue > 0 do
			local head = heapPeek(self._queue)
			if not head then
				task.wait()
				continue
			end

			local tnow = now()
			local waitTime = head.at - tnow
			
			-- Tối ưu: Chỉ wait nếu cần thiết
			if waitTime > SLACK then
				task.wait(waitTime)
				tnow = now()
			end

			local batchCount = 0
			local slackBoundary = tnow + SLACK
			
			-- Tối ưu: Process tất cả jobs trong SLACK window
			while #self._queue > 0 do
				local peeked = heapPeek(self._queue)
				if not peeked or peeked.at > slackBoundary then
					break
				end

				local item = heapPop(self._queue)
				if not item then break end

				local j = self._jobs[item.name]

				-- Early exit conditions
				if not j or not j.enabled then
					continue
				end
				
				-- Tối ưu: Dùng epsilon comparison thay vì math.abs
				if item.at ~= j.nextAt and math_abs(item.at - j.nextAt) > 1e-6 then
					continue
				end
				
				if j.running then
					-- Skip và schedule lại
					self:_planNext(j, j.interval)
					continue
				end

				j.running = true
				local ok, ret = pcall(j.fn)
				j.running = false

				-- Tối ưu: Inline logic
				if ok and type(ret) == "number" and ret >= 0 then
					self:_planNext(j, ret)
				else
					self:_planNext(j, nil)
				end

				batchCount += 1
				
				-- Tối ưu: Yield less frequently
				if batchCount >= MAX_BATCH then
					task.wait()
					tnow = now()
					slackBoundary = tnow + SLACK
					batchCount = 0
				end
			end
			
			-- Tối ưu: Micro-yield nếu còn jobs
			if #self._queue > 0 then
				task.wait()
			end
		end

		self._runnerAlive = false
	end)
end

function Tick:add(name: string, interval: number, fn: (() -> (number|nil)), jitterPct: number?)
	local j = self._jobs[name]
	
	if j == nil then
		j = {
			name = name,
			interval = interval,
			jitterPct = jitterPct or 0,
			running = false,
			enabled = true,
			fn = fn,
			nextAt = 0,
			version = 0,
		}
		self._jobs[name] = j
	else
		j.interval = interval
		j.jitterPct = jitterPct or j.jitterPct
		j.fn = fn
		j.enabled = true
	end
	
	j.version += 1
	self:_planNext(j, withJitter(interval, j.jitterPct))
end

function Tick:enable(name: string, on: boolean)
	local j = self._jobs[name]
	if not j or j.enabled == on then return end
	
	j.enabled = on
	j.version += 1
	
	if on then
		self:_planNext(j, withJitter(j.interval, j.jitterPct))
	end
end

function Tick:cancel(name: string)
	local j = self._jobs[name]
	if not j then return end
	
	j.enabled = false
	j.version += 1
	self._jobs[name] = nil
end

return Tick
