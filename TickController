-- Tick.lua (Đã sửa lỗi)
--!strict
local Tick = {}
Tick.__index = Tick

type Job = {
	name: string,
	interval: number,
	jitterPct: number,
	running: boolean,
	enabled: boolean,
	fn: (() -> (number|nil)),
	nextAt: number,            -- SỬA: Dùng os.clock()
	version: number,
}

-- Các thông số tinh chỉnh hiệu năng
local SLACK = 1/5            -- SỬA: Gom các job trong ~2 frame (33ms), hợp lý hơn
local MAX_BATCH = 8
local MIN_DELAY = 0.05

local function withJitter(base: number, pct: number): number
	if pct <= 0 then return base end
	local d = base * pct
	return math.max(MIN_DELAY, base + (math.random() * 2 * d - d))
end

local function now(): number
	-- SỬA: Luôn dùng os.clock() để đồng bộ với task.wait()
	return os.clock()
end

-- (Các hàm queue... không thay đổi)
local function queueInsert(q: { {name: string, at: number} }, item)
	local i = #q + 1
	q[i] = item
	while i > 1 and q[i-1].at > q[i].at do
		q[i-1], q[i] = q[i], q[i-1]
		i -= 1
	end
end
local function queuePeek(q) return q[1] end
local function queuePop(q)
	if #q == 0 then return nil end
	local it = q[1]
	table.remove(q, 1)
	return it
end


function Tick.new()
	local self = setmetatable({}, Tick)
	self._jobs = {} :: {[string]: Job}
	self._queue = {} :: { {name: string, at: number} }
	self._runnerAlive = false
	return self
end

function Tick:_planNext(j: Job, delaySec: number?)
	local d = delaySec
	if d == nil then
		d = withJitter(j.interval, j.jitterPct)
	end
	local t = math.max(MIN_DELAY, d :: number)
	j.nextAt = now() + t
	queueInsert(self._queue, { name = j.name, at = j.nextAt })
	if not self._runnerAlive then
		self:_startRunner()
	end
end

-- SỬA: Cải thiện logic runner, bỏ goto
function Tick:_startRunner()
	if self._runnerAlive then return end
	self._runnerAlive = true

	task.spawn(function()
		while #self._queue > 0 do
			local head = queuePeek(self._queue)
			if not head then
				-- Hàng đợi có thể bị rỗng tạm thời giữa các lần xử lý
				task.wait()
				continue
			end

			local tnow = now()
			if head.at > tnow then
				task.wait(head.at - tnow)
				tnow = now()
			end

			local batchCount = 0
			while #self._queue > 0 do
				local peeked = queuePeek(self._queue)
				if not peeked or peeked.at > (tnow + SLACK) then
					break -- Dừng batch nếu job kế tiếp nằm ngoài khoảng SLACK
				end

				local item = queuePop(self._queue)
				if not item then break end

				local j = self._jobs[item.name]

				-- Sử dụng continue thay cho goto để code sạch hơn
				if not j or not j.enabled or math.abs(item.at - j.nextAt) > 1e-6 then
					continue
				end
				
				if j.running then
					-- SỬA: Nếu đang chạy, bỏ qua và chờ lần kế tiếp thay vì spam lịch
					warn("Tick: Job '"..j.name.."' is still running, skipping this execution.")
					self:_planNext(j, j.interval) -- Lên lịch lại theo interval gốc
					continue
				end

				j.running = true
				local ok, ret = pcall(j.fn)
				j.running = false

				local delay: number? = nil
				if ok and type(ret) == "number" and ret >= 0 then
					delay = ret
				end
				self:_planNext(j, delay)

				batchCount += 1
				if batchCount >= MAX_BATCH then
					task.wait()
					tnow = now()
					batchCount = 0
				end
			end
		end

		self._runnerAlive = false
	end)
end

-- (Các hàm add, enable, cancel không thay đổi)
function Tick:add(name: string, interval: number, fn: (() -> (number|nil)), jitterPct: number?)
	local j = self._jobs[name]
	if j == nil then
		j = { name = name, interval = interval, jitterPct = jitterPct or 0, running = false, enabled = true, fn = fn, nextAt = 0, version = 0, }
		self._jobs[name] = j
	else
		j.interval = interval; j.jitterPct = jitterPct or j.jitterPct; j.fn = fn; j.enabled = true
	end
	j.version += 1
	self:_planNext(j, withJitter(interval, j.jitterPct))
end

function Tick:enable(name: string, on: boolean)
	local j = self._jobs[name]
	if not j or j.enabled == on then return end
	j.enabled = on
	j.version += 1
	if on then
		self:_planNext(j, withJitter(j.interval, j.jitterPct))
	end
end

function Tick:cancel(name: string)
	local j = self._jobs[name]
	if not j then return end
	j.enabled = false
	j.version += 1
	self._jobs[name] = nil
end


return Tick
