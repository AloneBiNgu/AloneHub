-- Tick.lua
--!strict
local Tick = {}
Tick.__index = Tick

type Job = {
	name: string,
	interval: number,          -- giây
	jitterPct: number,         -- vd: 0.2 => ±20%
	running: boolean,
	enabled: boolean,
	fn: (() -> (number|nil)),
	nextAt: number,            -- thời điểm (time()) chạy lần tới
	version: number,           -- tăng mỗi lần add/cancel/enable/disable
}

local SLACK = 1/60            -- gom các job đến hạn trong ~1 frame
local MAX_BATCH = 8           -- tối đa số job xử lý liên tục trước khi nhường CPU

local function withJitter(base: number, pct: number): number
	if pct <= 0 then return base end
	local d = base * pct
	return math.max(0.05, base + (math.random() * 2 * d - d))
end

local function now(): number
	-- dùng wall-clock thay vì os.clock()
	return time()
end

-- Hàng đợi (ưu tiên theo nextAt, nhỏ trước)
local function queueInsert(q: { {name: string, at: number} }, item)
	-- chèn giữ q luôn tăng dần theo at (O(n) đủ dùng, nếu >1k job có thể nâng cấp min-heap)
	local i = #q + 1
	q[i] = item
	while i > 1 and q[i-1].at > q[i].at do
		q[i-1], q[i] = q[i], q[i-1]
		i -= 1
	end
end

local function queuePeek(q) return q[1] end
local function queuePop(q)
	if #q == 0 then return nil end
	local it = q[1]
	table.remove(q, 1)
	return it
end

function Tick.new()
	local self = setmetatable({}, Tick)
	self._jobs = {} :: {[string]: Job}
	self._queue = {} :: { {name: string, at: number} }
	self._runnerAlive = false
	return self
end

-- nội bộ: lên lịch lần kế cho 1 job
function Tick:_planNext(j: Job, delaySec: number?)
	local d = delaySec
	if d == nil then
		d = withJitter(j.interval, j.jitterPct)
	end
	local t = math.max(0.05, d :: number)
	j.nextAt = now() + t
	-- Đưa vào queue (runner sẽ tự bỏ qua entry cũ nếu không khớp)
	queueInsert(self._queue, { name = j.name, at = j.nextAt })
	-- đảm bảo runner chạy
	if not self._runnerAlive then
		self:_startRunner()
	end
end

-- nội bộ: runner toàn cục chạy tuần tự
function Tick:_startRunner()
	if self._runnerAlive then return end
	self._runnerAlive = true

	task.spawn(function()
		while true do
			-- nếu rỗng thì tắt runner
			if #self._queue == 0 then
				self._runnerAlive = false
				return
			end

			local head = queuePeek(self._queue)
			if not head then
				-- không có gì để làm, nhường 1 frame
				task.wait()
				continue
			end

			-- chờ tới hạn (wall-clock)
			local tnow = now()
			if head.at > tnow then
				task.wait(head.at - tnow)
				tnow = now() -- tính lại sau khi chờ
			end

			-- Xử lý theo batch: tất cả job đến hạn trong [tnow, tnow+SLACK]
			local batchCount = 0
			while #self._queue > 0 do
				local peeked = queuePeek(self._queue)
				if not peeked then break end
				if peeked.at > (tnow + SLACK) then break end

				local item = queuePop(self._queue)
				if not item then break end

				local j = self._jobs[item.name]
				if not j or not j.enabled then
					-- job bị huỷ/disable, bỏ qua
					goto continue_batch
				end

				-- Entry không còn khớp nextAt hiện tại → bỏ qua
				if math.abs(item.at - j.nextAt) > 1e-6 then
					goto continue_batch
				end

				-- Nếu đang running, dời nhẹ để tránh đụng
				if j.running then
					self:_planNext(j, 0.025) -- dời 25ms thay vì 250ms để giảm độ trễ
					goto continue_batch
				end

				j.running = true
				local ok, ret = pcall(j.fn)
				j.running = false

				local delay: number? = nil
				if ok and type(ret) == "number" and ret >= 0 then
					delay = ret
				end
				self:_planNext(j, delay)

				batchCount += 1
				if batchCount >= MAX_BATCH then
					-- Nhường CPU sau khi xử lý một mẻ
					task.wait()
					tnow = now()
					batchCount = 0
				end

				::continue_batch::
			end
			-- vòng while true sẽ lặp lại; nếu còn việc, nó lại tính head và đợi tới hạn mới
		end
	end)
end

function Tick:add(name: string, interval: number, fn: (() -> (number|nil)), jitterPct: number?)
	local j = self._jobs[name]
	if j == nil then
		j = {
			name = name,
			interval = interval,
			jitterPct = jitterPct or 0,
			running = false,
			enabled = true,
			fn = fn,
			nextAt = 0,
			version = 0,
		}
		self._jobs[name] = j
	else
		-- cập nhật lại cấu hình nếu add trùng tên
		j.interval = interval
		j.jitterPct = jitterPct or j.jitterPct
		j.fn = fn
		j.enabled = true
	end
	j.version += 1
	self:_planNext(j, withJitter(interval, j.jitterPct))
end

function Tick:enable(name: string, on: boolean)
	local j = self._jobs[name]
	if not j then return end
	if j.enabled == on then return end
	j.enabled = on
	j.version += 1
	if on then
		self:_planNext(j, withJitter(j.interval, j.jitterPct))
	end
end

function Tick:cancel(name: string)
	local j = self._jobs[name]
	if not j then return end
	j.enabled = false
	j.version += 1
	self._jobs[name] = nil
	-- Không cần dọn queue ngay: runner tự bỏ qua entry “mồ côi”
end

return Tick
