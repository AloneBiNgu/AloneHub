--!strict
local bit = bit32

local SLOT = 0.2           -- 5 FPS
local WHEEL = 256          -- 256 ô => 51.2s mỗi vòng
local WORDS = 2            -- 64 job tối đa (2 * 32-bit). Tăng nếu cần.

-- Mỗi ô có WORDS bitset (mỗi bit là 1 job)
local buckets = table.create(WHEEL)
for i = 1, WHEEL do
    local row = table.create(WORDS)
    for w = 1, WORDS do row[w] = 0 end
    buckets[i] = row
end

-- Job metadata: interval (ô), rounds (số vòng còn lại), enabled, running, fn
local JOB_MAX = WORDS * 32
local jobs = table.create(JOB_MAX)
for id = 1, JOB_MAX do
    jobs[id] = { interval = 0, rounds = 0, enabled = false, running = false, fn = nil }
end

-- Mapping tên -> id (1..JOB_MAX)
local idByName : {[string]: number} = {}
local nextId = 1

local cursor = 1 -- ô hiện tại (1..WHEEL)

local function wordBit(id: number)
    local w = ((id - 1) // 32) + 1
    local b = (id - 1) % 32
    return w, b
end

local function scheduleAtSlot(id: number, slotIndex: number, rounds: number)
    local j = jobs[id]
    j.rounds = rounds
    local row = buckets[slotIndex]
    local w, b = wordBit(id)
    row[w] = bit.bor(row[w], bit.lshift(1, b))
end

local function descheduleFromSlot(id: number, slotIndex: number)
    local row = buckets[slotIndex]
    local w, b = wordBit(id)
    row[w] = bit.band(row[w], bit.bnot(bit.lshift(1, b)))
end

local function add(name: string, intervalSec: number, fn: (() -> (number|nil)))
    local id = idByName[name]
    if not id then
        assert(nextId <= JOB_MAX, "Out of job slots")
        id = nextId
        nextId += 1
        idByName[name] = id
    end

    local ticks = math.max(1, math.floor(intervalSec / SLOT + 0.5)) -- lượng tử hóa
    local rounds = (ticks - 1) // WHEEL
    local advance = ((ticks - 1) % WHEEL) + 1
    local slotIndex = ((cursor - 1 + advance) % WHEEL) + 1

    local j = jobs[id]
    j.interval = ticks
    j.enabled = true
    j.running = false
    j.fn = fn

    scheduleAtSlot(id, slotIndex, rounds)
end

local function cancel(name: string)
    local id = idByName[name]; if not id then return end
    local j = jobs[id]; if not j.enabled then return end
    j.enabled = false
    j.fn = nil
    -- Không cần dọn bit ngay: sẽ tự rơi khi rounds==0 & tới slot thì bỏ qua vì disabled
end

local function enable(name: string, on: boolean)
    local id = idByName[name]; if not id then return end
    local j = jobs[id]
    j.enabled = on and true or false
end

-- Tính lại vị trí tương lai dựa trên interval (ticks)
local function reschedFromCurrent(id: number)
    local j = jobs[id]
    local ticks = math.max(1, j.interval)
    local rounds = (ticks - 1) // WHEEL
    local advance = ((ticks - 1) % WHEEL) + 1
    local slotIndex = ((cursor - 1 + advance) % WHEEL) + 1
    scheduleAtSlot(id, slotIndex, rounds)
end

-- Runner: mỗi SLOT giây, nhảy một ô
task.spawn(function()
    while true do
        task.wait(SLOT)
        cursor = (cursor % WHEEL) + 1
        local row = buckets[cursor]

        -- Quét từng word (32 job/word)
        for w = 1, WORDS do
            local mask = row[w]
            if mask ~= 0 then
                -- Duyệt bit: vòng 0..31
                for b = 0, 31 do
                    local bitmask = bit.lshift(1, b)
                    if bit.band(mask, bitmask) ~= 0 then
                        local id = (w - 1) * 32 + (b + 1)
                        local j = jobs[id]
                        if j and j.enabled then
                            if j.rounds > 0 then
                                -- chưa tới vòng chạy, giảm rounds và giữ bit
                                j.rounds -= 1
                            else
                                -- tới lượt chạy
                                -- gỡ bit hiện tại
                                row[w] = bit.band(row[w], bit.bnot(bitmask))
                                -- chạy job
                                if not j.running and j.fn then
                                    j.running = true
                                    local ok, backoff = pcall(j.fn)
                                    j.running = false

                                    -- tạm chọn backoff nếu có (lượng tử hóa theo SLOT)
                                    if ok and type(backoff) == "number" and backoff >= 0 then
                                        j.interval = math.max(1, math.floor(backoff / SLOT + 0.5))
                                    end
                                else
                                    -- nếu đang running, lần sau chạy lại (không resched ở đây)
                                end
                                -- đặt lại lịch tương lai (nếu vẫn enabled)
                                if j.enabled then
                                    reschedFromCurrent(id)
                                end
                            end
                        else
                            -- disabled: gỡ bit
                            row[w] = bit.band(row[w], bit.bnot(bitmask))
                        end
                    end
                end
            end
        end
    end
end)

-- API export (rút gọn)
return {
    add = add,
    cancel = cancel,
    enable = enable,
}
